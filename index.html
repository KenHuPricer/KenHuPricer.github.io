<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>擲茭模擬器 - 人生方向指引</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Three.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* Custom styles */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6; /* Light gray background */
        }
        /* Style for the 3D canvas container */
        #threejs-container {
            width: 100%;
            height: 256px; /* Fixed height for the canvas container */
            background-color: #e0e7eb; /* Slightly darker background for the 3D area */
            border-radius: 1rem; /* Rounded corners */
            overflow: hidden; /* Ensure canvas stays within bounds */
        }
        canvas {
            display: block; /* Remove extra space below canvas */
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-4 bg-gray-100 text-gray-800">
    <div class="bg-white p-8 rounded-2xl shadow-xl max-w-2xl w-full text-center">
        <h1 class="text-4xl font-extrabold text-amber-800 mb-6">
            擲茭模擬器
        </h1>
        <p class="text-lg text-gray-600 mb-8">
            專注您的問題，點擊「擲茭」按鈕，看看神明的指引。
        </p>

        <!-- 3D 擲茭顯示區域 -->
        <div class="flex justify-center items-center mb-10 h-64 w-full relative">
            <div id="threejs-container" class="shadow-inner">
                <!-- Three.js 渲染的 canvas 將會被附加到這裡 -->
            </div>
        </div>

        <button id="throwButton" class="bg-amber-600 hover:bg-amber-700 text-white font-bold py-4 px-8 rounded-full shadow-lg transition-all duration-300 ease-in-out transform hover:scale-105 active:scale-95 focus:outline-none focus:ring-4 focus:ring-amber-300 mb-8 text-xl">
            擲茭
        </button>

        <div id="resultDisplay" class="mb-8 p-6 bg-amber-50 rounded-xl border border-amber-200 shadow-inner">
            <h2 id="resultTitle" class="text-3xl font-bold text-amber-700 mb-2"></h2>
            <p id="resultExplanation" class="text-lg text-gray-700 leading-relaxed"></p>
        </div>

        <div class="bg-amber-50 p-6 rounded-xl border border-amber-200 shadow-inner text-left">
            <h3 class="text-2xl font-bold text-amber-700 mb-4">結果說明：</h3>
            <ul class="list-disc list-inside text-gray-700 space-y-3">
                <li>
                    <span class="font-semibold text-amber-800">聖筊 (Sheng Jiao)</span>：
                    <span class="text-gray-600">一個反面、一個正面。表示神明同意、贊成，是肯定的答案。</span>
                    <span class="block text-sm text-gray-500 mt-1">（示意圖：一個筊平坦面朝上，一個筊弧面朝上）</span>
                </li>
                <li>
                    <span class="font-semibold text-amber-800">笑筊 (Xiao Jiao)</span>：
                    <span class="text-gray-600">兩個筊皆呈現弧面朝上。表示神明笑而不答，可能有以下含義：問題不夠明確、問題太過簡單、答案你心中已有、或神明覺得好笑。通常需重新請示。</span>
                    <span class="block text-sm text-gray-500 mt-1">（示意圖：兩個筊皆弧面朝上）</span>
                </li>
                <li>
                    <span class="font-semibold text-amber-800">陰筊 (Yin Jiao) / 哭筊 (Ku Jiao)</span>：
                    <span class="text-gray-600">兩個筊皆呈現平坦面朝上。表示神明不同意、不贊成，是否定的答案，或神明有所不悅。通常需重新請示。</span>
                    <span class="block text-sm text-gray-500 mt-1">（示意圖：兩個筊皆平坦面朝上）</span>
                </li>
            </ul>
        </div>
    </div>

    <script>
        // Three.js 全局變數
        let scene, camera, renderer;
        let jiao1, jiao2; // 我們的 3D 筊物件
        const THROW_DURATION = 1500; // 動畫持續時間 (毫秒)

        // 獲取 DOM 元素
        const throwButton = document.getElementById('throwButton');
        const resultTitle = document.getElementById('resultTitle');
        const resultExplanation = document.getElementById('resultExplanation');
        const threejsContainer = document.getElementById('threejs-container');

        /**
         * 初始化 Three.js 場景、攝影機、渲染器和燈光。
         */
        function init3DScene() {
            // 場景 (Scene)
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xe0e7eb); // 與容器背景匹配

            // 攝影機 (Camera)
            // 縱橫比將在 onWindowResize 中設定
            camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
            camera.position.set(0, 5, 10); // 調整攝影機位置以查看地板和筊塊
            camera.lookAt(0, 0, 0);

            // 渲染器 (Renderer)
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true; // 啟用陰影
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; // 柔和陰影
            threejsContainer.appendChild(renderer.domElement);

            // 設定初始尺寸並添加視窗大小調整監聽器
            onWindowResize(); // 呼叫一次以設定初始尺寸
            window.addEventListener('resize', onWindowResize);

            // 燈光 (Lights)
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); // 柔和白光
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8); // 較亮的光源
            directionalLight.position.set(5, 10, 7.5).normalize();
            directionalLight.castShadow = true; // 啟用陰影投射
            // 配置陰影貼圖
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -10;
            directionalLight.shadow.camera.right = 10;
            directionalLight.shadow.camera.top = 10;
            directionalLight.shadow.camera.bottom = -10;
            scene.add(directionalLight);

            // 地面 (Ground Plane)
            const planeGeometry = new THREE.PlaneGeometry(20, 20);
            const planeMaterial = new THREE.MeshStandardMaterial({ color: 0xcccccc, side: THREE.DoubleSide });
            const plane = new THREE.Mesh(planeGeometry, planeMaterial);
            plane.rotation.x = Math.PI / 2; // 旋轉為平面
            plane.position.y = -0.2; // 筊塊將落在這個平面上
            plane.receiveShadow = true; // 接收陰影
            scene.add(plane);

            // 創建筊塊 (使用圓柱體作為近似)
            const jiaoMaterial = new THREE.MeshStandardMaterial({ color: 0xfbd38d, roughness: 0.7, metalness: 0.2 }); // 金色材質

            /**
             * 創建一個 3D 筊塊模型 (圓柱體)。
             * @returns {THREE.Mesh} 3D 筊塊網格物件。
             */
            function createJiao() {
                // 一個薄而寬的圓柱體，近似於筊塊的形狀。
                // 它可以落在其平面或弧形邊緣上。
                const radius = 1.2; // 半徑
                const height = 0.4; // 高度 (厚度)
                const radialSegments = 32; // 徑向分段數
                const jiaoGeometry = new THREE.CylinderGeometry(radius, radius, height, radialSegments);
                const jiao = new THREE.Mesh(jiaoGeometry, jiaoMaterial);
                jiao.castShadow = true; // 投射陰影
                jiao.receiveShadow = true; // 接收陰影
                return jiao;
            }

            jiao1 = createJiao();
            jiao2 = createJiao();

            scene.add(jiao1);
            scene.add(jiao2);
        }

        /**
         * 處理視窗大小調整事件，更新攝影機縱橫比和渲染器尺寸。
         */
        function onWindowResize() {
            const width = threejsContainer.clientWidth;
            const height = threejsContainer.clientHeight;
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        }

        /**
         * Three.js 動畫循環。
         */
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        /**
         * 動畫單個筊塊的投擲過程，包括位置和旋轉。
         * @param {THREE.Mesh} jiao - 要動畫的 3D 筊塊物件。
         * @param {number} targetRotationX - 最終在 X 軸上的目標旋轉角度 (弧度)。
         * @param {number} targetPositionX - 最終在 X 軸上的目標位置。
         */
        function animateJiao(jiao, targetRotationX, targetPositionX) {
            const startTime = Date.now();
            const startPosition = jiao.position.clone();
            const initialRotation = jiao.rotation.clone(); // 捕獲初始旋轉

            // 定義投擲階段的隨機總旋轉量 (使其翻滾)
            const randomTumbleX = initialRotation.x + (Math.random() - 0.5) * Math.PI * 6;
            const randomTumbleY = initialRotation.y + (Math.random() - 0.5) * Math.PI * 10;
            const randomTumbleZ = initialRotation.z + (Math.random() - 0.5) * Math.PI * 6;

            // 定義最終的 Y 軸旋轉以增加美學多樣性，同時保持穩定
            const finalRotationY = Math.random() * Math.PI * 2;


            const animateStep = () => {
                const elapsed = Date.now() - startTime;
                let progress = Math.min(elapsed / THROW_DURATION, 1);

                // 使用 Ease-in-out 函數實現平滑運動
                const easedProgress = 0.5 - 0.5 * Math.cos(progress * Math.PI);

                // 位置動畫 (弧形運動和展開)
                const midPointY = 3; // 弧形的最高點高度
                jiao.position.x = startPosition.x + (targetPositionX - startPosition.x) * easedProgress;
                jiao.position.y = midPointY * Math.sin(progress * Math.PI); // 拋物線弧形
                jiao.position.z = 0; // 保持 Z 軸不變


                // 旋轉動畫：結合飛行中的翻滾和最終著地的平穩過渡
                if (progress < 0.7) { // 翻滾階段 (動畫的前 70%)
                    const tumbleProgress = progress / 0.7; // 計算翻滾階段的進度 (0 到 1)
                    jiao.rotation.x = THREE.MathUtils.lerp(initialRotation.x, randomTumbleX, tumbleProgress);
                    jiao.rotation.y = THREE.MathUtils.lerp(initialRotation.y, randomTumbleY, tumbleProgress);
                    jiao.rotation.z = THREE.MathUtils.lerp(initialRotation.z, randomTumbleZ, tumbleProgress);
                } else { // 著地階段 (動畫的後 30%)
                    const settleProgress = (progress - 0.7) / 0.3; // 計算著地階段的進度 (0 到 1)
                    const settledEasedProgress = 0.5 - 0.5 * Math.cos(settleProgress * Math.PI); // 平滑著地過渡

                    // 從當前旋轉 (翻滾後) 平滑過渡到最終目標旋轉
                    jiao.rotation.x = THREE.MathUtils.lerp(jiao.rotation.x, targetRotationX, settledEasedProgress);
                    jiao.rotation.y = THREE.MathUtils.lerp(jiao.rotation.y, finalRotationY, settledEasedProgress);
                    jiao.rotation.z = THREE.MathUtils.lerp(jiao.rotation.z, 0, settledEasedProgress); // 確保 Z 軸平坦
                }

                if (progress < 1) {
                    requestAnimationFrame(animateStep);
                } else {
                    // 動畫完成後確保最終狀態精確
                    jiao.position.set(targetPositionX, 0, 0); // 落在地面上 (Y=0)
                    jiao.rotation.set(targetRotationX, finalRotationY, 0); // 設定最終旋轉
                }
            };

            animateStep();
        }

        /**
         * 模擬擲出單個筊塊的結果。
         * @returns {'rounded'|'flat'} 'rounded' 表示弧面朝上，'flat' 表示平坦面朝上。
         */
        function throwBlockSimulate() {
            return Math.random() < 0.5 ? 'rounded' : 'flat';
        }

        /**
         * 重置筊塊的視覺狀態到初始位置和預設旋轉。
         */
        function resetJiaoVisuals() {
            jiao1.position.set(-1.5, 0, 0);
            jiao2.position.set(1.5, 0, 0);
            // 預設為 '弧面' 朝上 (圓柱體平躺)
            jiao1.rotation.set(Math.PI / 2, 0, 0);
            jiao2.rotation.set(Math.PI / 2, 0, 0);
        }

        // 擲茭按鈕點擊事件監聽器
        throwButton.addEventListener('click', () => {
            // 動畫期間禁用按鈕
            throwButton.disabled = true;
            throwButton.textContent = '擲茭中...';
            throwButton.classList.add('opacity-70', 'cursor-not-allowed');

            // 重置文字顯示
            resultTitle.textContent = '';
            resultExplanation.textContent = '';

            // 動畫前確定擲茭結果
            const result1 = throwBlockSimulate();
            const result2 = throwBlockSimulate();

            // 根據模擬結果確定目標旋轉角度
            // 'rounded' (弧面朝上): 圓柱體平躺 (X 軸旋轉 PI/2)
            // 'flat' (平坦面朝上): 圓柱體直立 (X 軸旋轉 0)
            const targetRotationX1 = result1 === 'rounded' ? Math.PI / 2 : 0;
            const targetRotationX2 = result2 === 'rounded' ? Math.PI / 2 : 0;

            // 動畫筊塊
            // 將它們稍微分開以獲得更好的可見性
            animateJiao(jiao1, targetRotationX1, -2.5); // 落在左側
            animateJiao(jiao2, targetRotationX2, 2.5);  // 落在右側

            // 動畫完成後解釋結果並顯示文字
            setTimeout(() => {
                let title = '';
                let explanation = '';

                if ((result1 === 'rounded' && result2 === 'flat') || (result1 === 'flat' && result2 === 'rounded')) {
                    title = '聖筊 (Sheng Jiao)';
                    explanation = '恭喜！這表示神明同意、贊成您的問題。';
                } else if (result1 === 'rounded' && result2 === 'rounded') {
                    title = '笑筊 (Xiao Jiao)';
                    explanation = '神明笑而不答，可能表示您的問題不夠明確，或答案您心中已有。請重新請示。';
                } else { // 兩個都是平坦面
                    title = '陰筊 (Yin Jiao) / 哭筊 (Ku Jiao)';
                    explanation = '神明不同意、不贊成，或有所不悅。請重新請示並檢視您的問題。';
                }

                resultTitle.textContent = title;
                resultExplanation.textContent = explanation;

                throwButton.disabled = false;
                throwButton.textContent = '擲茭';
                throwButton.classList.remove('opacity-70', 'cursor-not-allowed');
            }, THROW_DURATION + 100); // 在動畫結束後增加一個小緩衝，確保最終狀態已渲染
        });

        // 視窗載入時初始化 3D 場景並開始動畫循環
        window.onload = () => {
            init3DScene();
            resetJiaoVisuals(); // 設定筊塊的初始視覺狀態
            animate(); // 開始動畫循環
        };
    </script>
</body>
</html>
